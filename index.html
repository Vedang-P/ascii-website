<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Camera Feed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #asciiOutput {
            font-family: 'Courier New', monospace;
            white-space: pre;
            line-height: 0.8;
            letter-spacing: 0;
            overflow: hidden;
            transform-origin: top left;
            color: #4ade80;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col min-h-screen">

    <!-- Header -->
    <header class="p-6 bg-gray-800 border-b border-gray-700">
        <h1 class="text-3xl font-semibold text-center text-gray-100">ASCII Camera Feed</h1>
    </header>

    <!-- Main Content: Two side-by-side windows -->
    <main class="flex-grow flex flex-col lg:flex-row p-6 gap-6">

        <!-- Input Window (Camera Feed) -->
        <div class="flex-1 flex flex-col">
            <h2 class="text-lg font-medium text-gray-200 mb-4 text-center">Camera Input</h2>
            <div class="flex-1 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden p-4">
                <video id="cameraFeed" autoplay playsinline muted class="w-full h-full object-cover rounded-md transform -scale-x-100"></video>
            </div>
            <div id="message-box" class="mt-3 text-center text-red-400 text-sm"></div>
        </div>

        <!-- Output Window (ASCII Art) -->
        <div class="flex-1 flex flex-col">
            <h2 class="text-lg font-medium text-gray-200 mb-4 text-center">ASCII Output</h2>
            <div id="asciiContainer" class="flex-1 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden p-2 relative">
                <div id="asciiOutput" class="absolute top-0 left-0"></div>
            </div>
        </div>

    </main>

    <!-- Hidden canvas for processing -->
    <canvas id="hiddenCanvas" style="display: none;"></canvas>

    <script>
        const videoElement = document.getElementById('cameraFeed');
        const asciiOutput = document.getElementById('asciiOutput');
        const asciiContainer = document.getElementById('asciiContainer');
        const messageBox = document.getElementById('message-box');
        const canvas = document.getElementById('hiddenCanvas');
        const ctx = canvas.getContext('2d');

        // ASCII characters from darkest to lightest
        const asciiChars = '@%#*+=-:. ';
        
        let animationId;

        // Convert RGB to grayscale
        function rgbToGray(r, g, b) {
            return Math.round(0.299 * r + 0.587 * g + 0.114 * b);
        }

        // Convert grayscale value to ASCII character
        function grayToAscii(gray) {
            const index = Math.floor((gray / 255) * (asciiChars.length - 1));
            return asciiChars[index];
        }

        // Calculate optimal ASCII dimensions and scaling
        function calculateOptimalSettings() {
            const containerRect = asciiContainer.getBoundingClientRect();
            const availableWidth = containerRect.width - 16; // Account for padding
            const availableHeight = containerRect.height - 16;

            // Start with a base font size and calculate how many characters fit
            let fontSize = 8;
            let charWidth, charHeight;
            
            // Create a temporary element to measure character dimensions
            const tempElement = document.createElement('div');
            tempElement.style.font = `${fontSize}px Courier New`;
            tempElement.style.position = 'absolute';
            tempElement.style.visibility = 'hidden';
            tempElement.style.whiteSpace = 'pre';
            tempElement.style.lineHeight = '0.8';
            tempElement.textContent = 'M';
            document.body.appendChild(tempElement);
            
            const tempRect = tempElement.getBoundingClientRect();
            charWidth = tempRect.width;
            charHeight = tempRect.height * 0.8; // Account for line-height
            
            document.body.removeChild(tempElement);

            // Calculate how many characters can fit
            const maxCharsWidth = Math.floor(availableWidth / charWidth);
            const maxCharsHeight = Math.floor(availableHeight / charHeight);

            // Ensure we have reasonable dimensions
            const asciiWidth = Math.max(40, Math.min(maxCharsWidth, 120));
            const asciiHeight = Math.max(20, Math.min(maxCharsHeight, 60));

            // Recalculate font size to perfectly fit the container
            const fontSizeByWidth = availableWidth / (asciiWidth * 0.6); // 0.6 accounts for character spacing
            const fontSizeByHeight = availableHeight / (asciiHeight * 0.8); // 0.8 is line-height
            fontSize = Math.min(fontSizeByWidth, fontSizeByHeight);

            return {
                asciiWidth,
                asciiHeight,
                fontSize: Math.max(fontSize, 3) // Minimum 3px font size
            };
        }

        // Generate ASCII art from video frame
        function generateAscii() {
            if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
                animationId = requestAnimationFrame(generateAscii);
                return;
            }

            const settings = calculateOptimalSettings();
            const { asciiWidth, asciiHeight, fontSize } = settings;

            // Apply the calculated font size
            asciiOutput.style.fontSize = `${fontSize}px`;
            
            canvas.width = asciiWidth;
            canvas.height = asciiHeight;

            // Draw video frame to canvas (scaled down)
            ctx.drawImage(videoElement, 0, 0, asciiWidth, asciiHeight);

            // Get image data
            const imageData = ctx.getImageData(0, 0, asciiWidth, asciiHeight);
            const pixels = imageData.data;

            let asciiArt = '';

            // Convert pixels to ASCII
            for (let y = 0; y < asciiHeight; y++) {
                for (let x = 0; x < asciiWidth; x++) {
                    const index = (y * asciiWidth + x) * 4;
                    const r = pixels[index];
                    const g = pixels[index + 1];
                    const b = pixels[index + 2];
                    
                    const gray = rgbToGray(r, g, b);
                    asciiArt += grayToAscii(gray);
                }
                if (y < asciiHeight - 1) asciiArt += '\n';
            }

            asciiOutput.textContent = asciiArt;
            
            // Center the ASCII art if it doesn't fill the entire space
            const outputRect = asciiOutput.getBoundingClientRect();
            const containerRect = asciiContainer.getBoundingClientRect();
            
            const offsetX = Math.max(0, (containerRect.width - outputRect.width) / 2);
            const offsetY = Math.max(0, (containerRect.height - outputRect.height) / 2);
            
            asciiOutput.style.left = `${offsetX}px`;
            asciiOutput.style.top = `${offsetY}px`;
            
            // Continue animation
            animationId = requestAnimationFrame(generateAscii);
        }

        // Access Camera
        async function setupCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user' 
                        } 
                    });
                    
                    videoElement.srcObject = stream;
                    
                    // Start ASCII generation when video is ready
                    videoElement.addEventListener('loadedmetadata', () => {
                        // Small delay to ensure container dimensions are available
                        setTimeout(() => {
                            generateAscii();
                        }, 100);
                    });
                    
                } catch (error) {
                    console.error("Error accessing camera: ", error);
                    let errorMessage = "Could not access the camera. Please grant permission in your browser.";
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMessage = "Camera access was denied. Please grant permission to use this feature.";
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        errorMessage = "No camera was found on this device.";
                    }
                    
                    messageBox.textContent = errorMessage;
                    videoElement.style.display = 'none';
                }
            } else {
                console.error("getUserMedia not supported on this browser!");
                messageBox.textContent = "Sorry, your browser does not support camera access.";
                videoElement.style.display = 'none';
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            // Recalculate on resize with a small debounce
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                if (animationId) {
                    // The next frame will automatically recalculate dimensions
                }
            }, 100);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
            }
        });

        // Run on page load
        window.addEventListener('load', setupCamera);
    </script>

</body>
</html>
